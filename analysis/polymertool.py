import _contactmap  # _contactmap module is the module generated by cython. 
import _subchaindist # _subchaindist module is the module generated by cython.
import _contactprob # _contactprob module is the module generated by cython. 
import _matrixnorm # _matrixnorm module is the module generated by cython. 
import numpy as np

__all__ = ['contactmap','subchaindist','contactmap','normmap']

def _convert_float32(x):
	# convert argument to numpy.float32 type
	if type(x) == np.ndarray:
		if x.dtype != np.float32:
			try:
				x = x.astype(np.float32,copy=False)
			except:
				raise
	else:
		try:
			x = np.array(x,dtype=np.float32)
		except:
			raise 
	return x

# ============================================================
# ------------------------------------------------------------
# calculate the contact matrices given a distance matrices  
# ------------------------------------------------------------

# ------------------------------------------------------------
# Usage:
# 		mypackage.analysis.contactmap(object,rc,mode='full')
# 		object: a numpy array or python list
#       rc: cutoff distance to determine a "contact"
#		mode: calculte the 'full' matrices or 'half' matrices. default value: full
#
# Example: 
#		import numpy as np
#		import mypackage as mp
#		x = np.random.rand(1000,3)
# 		dist = mp.pdist(x)
#		mp.analysis.polymertool.contactmap(dist,1.0,mode='half')
#		y = np.random.rand(1000,3)
#		dist = mp.cdist(x,y)
#		mp.analysis.polymertool.contactmap(dist,1.0)
# ------------------------------------------------------------

def contactmap(X,RC,mode = 'full'):
	x = _convert_float32(X)
	try:
		rc = float(RC)
	except:
		raise TypeError('cutoff distance need to be a real number')

	if mode != 'full' and mode != 'half':
		raise ValueError('only two modes available: half and full')

	return _contactmap.cmap(x,rc) if mode == 'full' else _contactmap.cmaphalf(x,rc)

# ============================================================
# ------------------------------------------------------------
# calculate the average distance between two monomers as a 
# function of the distance between to monomers along the chain
# R(s) where s =|i-j| is the chain distance of monomers
# ------------------------------------------------------------

# ------------------------------------------------------------
# Usage:
# 		mypackage.analysis.subchaindist(object)
# 		object: a numpy array or python list. This need to be 
#		a distance matrices
#
# Example: 
#		import numpy as np
#		import mypackage as mp
#		x = np.random.rand(1000,3)
# 		dist = mp.pdist(x)
#		mp.analysis.polymertool.subchaindist(dist)
# ------------------------------------------------------------

def subchaindist(X):
	x = _convert_float32(X)
	return _subchaindist.sbd(x)

# ============================================================
# ------------------------------------------------------------
# calculate the contact probability given a distance matrices. 
# the probability between two monomers as a function of their 
# distance along the chain.
# P(s) where s =|i-j| is the chain distance of monomers
# ------------------------------------------------------------

# ------------------------------------------------------------
# Usage:
# 		mypackage.analysis.polymertool.contactprob(object,rc)
# 		object: a numpy array or python list. This need to be
#		a distance matrices
#       rc: cutoff distance to determine a "contact"
#
# Example: 
#		import numpy as np
#		import mypackage as mp
#		x = np.random.rand(1000,3)
# 		dist = mp.pdist(x)
#		mp.analysis.polymertool.contactprob(dist,1.0)
# ------------------------------------------------------------

def contactprob(X,RC):
	x = _convert_float32(X)
	try:
		rc = float(RC)
	except:
		raise TypeError('cutoff distance need to be a real number')

	return _contactprob.cp(x,rc)

# ============================================================
# ------------------------------------------------------------
# coarse grain the contact map given a normalization factor
# Usage:
#               myPackage.analysis.polymertool.normmap(object,norm_factor,pc=None)
#               object: a contact map
#               norm_factor: a int
#               pc: probability contact array
# Example:
#               import numpy as np
#               import myPackage as mp
#               x = np.random.rand(100,100) # this is a contact map
#               mp.analysis.polymertool.normmap(x, 10) # this normalize map by a factor of 10
# ------------------------------------------------------------

def normmap(X,NF,PC = None):
        x = _convert_float32(X)
        if int(NF) != NF:
                raise TypeError('normalization factor should be an integer')
        nf = int(NF)

        if PC == None:
                return _matrixnorm.normmatrix(x, nf)
        else:
                pc = _convert_float32(PC)
                return _matrixnorm.normmatrix_OE(x, nf, pc)
